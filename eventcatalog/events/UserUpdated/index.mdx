---
id: UserUpdated
name: UserUpdated
version: '1.0'
summary: Event published by role service when userupdated occurs
owners:
  - role-service
producers:
  - role-service
consumers:
  - role-service
badges:
  - content: "Schema Valid âœ“"
    backgroundColor: "#22c55e"
    textColor: white
  - content: "Domain: Operations"
    backgroundColor: "#3b82f6"
    textColor: white
  - content: "v1.0"
    backgroundColor: "#6366f1"
    textColor: white
---

# UserUpdated Event

**Schema ID**: 999
**Schema Version**: 1.0
**Subject**: UserUpdatedEvent
**Domain**: Operations
**Service**: role-service
**Repository**: biopro-operations

## Business Context

Event published when userupdated occurs in the role service.

## Event Schema Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| eventId | UUID | Yes | Unique event identifier |
| occurredOn | timestamp-millis | Yes | When the event occurred |
| eventType | string | Yes | Event type identifier |
| eventVersion | string | Yes | Schema version |
| eventId | UUID | Yes |  |
| occurredOn | ZonedDateTime | Yes |  |
| eventType | String | Yes |  |
| eventVersion | String | Yes |  |
| id | String | Yes |  |
| username | String | Yes |  |

## Consumer Implementation with DLQ Support

### Spring Boot Kafka Listener

```java
package com.arcone.biopro.role.infrastructure.listener;

import com.arcone.biopro.role.domain.event.UserUpdatedEvent;
import com.arcone.biopro.common.infrastructure.listener.AbstractListener;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.support.KafkaHeaders;
import org.springframework.messaging.handler.annotation.Header;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

@Slf4j
@Service
@RequiredArgsConstructor
public class UserUpdatedEventListener extends AbstractListener<UserUpdatedEvent> {

    private final YourBusinessService businessService;

    @KafkaListener(
        topics = "${kafka.topics.userupdated}",
        groupId = "${kafka.consumer.group-id}",
        containerFactory = "kafkaListenerContainerFactory",
        errorHandler = "kafkaListenerErrorHandler"
    )
    public void listen(
            @Payload UserUpdatedEvent event,
            @Header(KafkaHeaders.RECEIVED_TOPIC) String topic,
            @Header(KafkaHeaders.RECEIVED_PARTITION) int partition,
            @Header(KafkaHeaders.OFFSET) long offset
    ) {
        log.info("Received UserUpdatedEvent: eventId={}, topic={}, partition={}, offset={}",
                event.getEventId(), topic, partition, offset);

        processMessage(event)
            .doOnSuccess(result ->
                log.info("Successfully processed UserUpdatedEvent: {}", event.getEventId()))
            .doOnError(error ->
                log.error("Failed to process UserUpdatedEvent: {}", event.getEventId(), error))
            .subscribe();
    }

    @Override
    protected Mono<UserUpdatedEvent> processMessage(UserUpdatedEvent event) {
        return Mono.defer(() -> {
            try {
                validateEvent(event);
                return businessService.handle(event)
                    .doOnError(this::handleBusinessError)
                    .onErrorResume(this::recoverFromError);
            } catch (InvalidEventException e) {
                log.error("Invalid event detected - routing to DLQ: {}", event.getEventId(), e);
                sendToDLQ(event, e);
                return Mono.empty();
            } catch (Exception e) {
                return handleUnexpectedError(event, e);
            }
        });
    }

    private void validateEvent(UserUpdatedEvent event) {
        if (event.getEventId() == null || event.getEventId().isEmpty()) {
            throw new InvalidEventException("Event ID is required");
        }
        // Add domain-specific validations
    }
}
```

## Complete Avro Schema

```json
{
  "type": "record",
  "name": "UserUpdatedEvent",
  "namespace": "com.arcone.biopro.operations.role.domain.event",
  "doc": "Event published when userupdated occurs",
  "fields": [
    {
      "name": "eventId",
      "type": {
        "type": "string",
        "logicalType": "uuid"
      },
      "doc": "Unique identifier for this event"
    },
    {
      "name": "occurredOn",
      "type": {
        "type": "long",
        "logicalType": "timestamp-millis"
      },
      "doc": "Timestamp when event occurred"
    },
    {
      "name": "occurredOnTimeZone",
      "type": "string",
      "doc": "Timezone for occurredOn",
      "default": "UTC"
    },
    {
      "name": "eventType",
      "type": "string",
      "doc": "Type of event",
      "default": "USERUPDATED"
    },
    {
      "name": "eventVersion",
      "type": "string",
      "doc": "Version of the event schema",
      "default": "1.0"
    },
    {
      "name": "eventId",
      "type": {
        "type": "string",
        "logicalType": "uuid"
      },
      "doc": "eventId field"
    },
    {
      "name": "occurredOn",
      "type": {
        "type": "long",
        "logicalType": "timestamp-millis"
      },
      "doc": "occurredOn field"
    },
    {
      "name": "eventType",
      "type": "string",
      "doc": "eventType field"
    },
    {
      "name": "eventVersion",
      "type": "string",
      "doc": "eventVersion field"
    },
    {
      "name": "id",
      "type": "string",
      "doc": "id field"
    },
    {
      "name": "username",
      "type": "string",
      "doc": "username field"
    }
  ]
}
```

## Change Log

### v1.0 (2025-11-16)
- Schema registered with ID 999
- Integrated with Schema Registry
- DLQ error handling configured

<NodeGraph />
